project('ffi_test', ['c', 'rust'])

find_program('cargo', required : true)
cargo_build = find_program('cargo_rust_from_c/cargo.sh')

if get_option('release')
    message('Release mode enabled')
    cargo_args = ['--release']
    grab_objects_arg = 'release'
else
    message('Debug mode enabled')
    cargo_args = []
    grab_objects_arg = 'debug'
endif

message('Running cargo...')
cargo_result = run_command(cargo_build, cargo_args)
cargo_stdout = cargo_result.stdout().strip()
cargo_stderr = cargo_result.stderr().strip()
if cargo_stderr != ''
    message(cargo_stderr)
elif cargo_stdout != ''
    message(cargo_stdout)
else
    message('Cargo is done')
endif

# Here we grab any shared library objects from Cargo's generated "target" directory
# using a shell script to take advantage of wildcards.
grab_objects = find_program('cargo_rust_from_c/grab_objects.sh')

# The output is sanitized and made into an array.
cargo_rslib_objects = run_command(grab_objects, grab_objects_arg).stdout().strip().split('\n')

message('Found objects:')
message(cargo_rslib_objects)

executable(
    'cexe', 'rust_from_c/main.c',
    link_with : library('rslib', 'rust_from_c/lib.rs'),
    objects : cargo_rslib_objects
    # The objects generated by cargo are put here so they can be
    # linked with the C executable.

    # This method seems like it may be a little dirty, but it's the
    # only method I could find.
)

executable(
    'rsexe', 'c_from_rust/main.rs',
    link_with : library('clib', 'c_from_rust/lib.c')
)
